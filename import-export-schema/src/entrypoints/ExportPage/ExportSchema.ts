/**
 * 'bulk exports' widened this helper so importer/graph code could reuse
 * the same normalized view of a schema export. v2 exports optionally declare multiple root
 * item types, but v1 files assumed a single implicit root; the coalescing logic keeps
 * both behaviours working so older exports still import cleanly.
 */
import type { SchemaTypes } from '@datocms/cma-client';
import get from 'lodash-es/get';
import { findLinkedItemTypeIds } from '@/utils/datocms/schema';
import { isDefined } from '@/utils/isDefined';
import type { ExportDoc } from '@/utils/types';

/**
 * Normalizes an export document into easy-to-query maps, helping both import and graph builders.
 */
export class ExportSchema {
  public rootItemType: SchemaTypes.ItemType;
  public rootItemTypes: SchemaTypes.ItemType[];
  public itemTypesById: Map<string, SchemaTypes.ItemType>;
  public pluginsById: Map<string, SchemaTypes.Plugin>;
  public fieldsById: Map<string, SchemaTypes.Field>;
  public fieldsetsById: Map<string, SchemaTypes.Fieldset>;

  constructor(exportDoc: ExportDoc) {
    this.itemTypesById = new Map();
    for (const itemType of exportDoc.entities.filter(
      (e): e is SchemaTypes.ItemType => e.type === 'item_type',
    )) {
      // Normalize ID to string to avoid number/string key mismatches
      this.itemTypesById.set(String(itemType.id), itemType);
    }

    this.pluginsById = new Map();
    for (const plugin of exportDoc.entities.filter(
      (e): e is SchemaTypes.Plugin => e.type === 'plugin',
    )) {
      this.pluginsById.set(String(plugin.id), plugin);
    }

    this.fieldsById = new Map();
    for (const field of exportDoc.entities.filter(
      (e): e is SchemaTypes.Field => e.type === 'field',
    )) {
      this.fieldsById.set(String(field.id), field);
    }

    this.fieldsetsById = new Map();
    for (const fieldset of exportDoc.entities.filter(
      (e): e is SchemaTypes.Fieldset => e.type === 'fieldset',
    )) {
      this.fieldsetsById.set(String(fieldset.id), fieldset);
    }

    // Compute roots by inspecting field link targets (no incoming edges)
    const targetItemTypeIds = new Set<string>();
    for (const field of this.fields) {
      const itemTypeId = String(field.relationships.item_type.data.id);
      for (const linkedItemTypeId of findLinkedItemTypeIds(field)) {
        if (String(linkedItemTypeId) !== itemTypeId) {
          targetItemTypeIds.add(String(linkedItemTypeId));
        }
      }
    }

    this.rootItemTypes = this.itemTypes.filter(
      (itemType) => !targetItemTypeIds.has(itemType.id),
    );

    if (exportDoc.version === '1') {
      if (this.rootItemTypes.length !== 1) {
        throw new Error(
          'This export file was generated by an older version of this plugin, and it is invalid because the initial model/block model cannot be determined. Please update to the most recent version of the plugin and export your schema once more.',
        );
      }
      this.rootItemType = this.rootItemTypes[0];
    } else {
      // Prefer explicit root in v2 for backward compatibility; fall back to computed roots
      const explicitRootId = exportDoc.rootItemTypeId;
      if (explicitRootId) {
        this.rootItemType = this.getItemTypeById(String(explicitRootId));
        // Ensure it exists in the list, even if incoming edge analysis differs
        if (
          !this.rootItemTypes.find(
            (it) => String(it.id) === String(explicitRootId),
          )
        ) {
          this.rootItemTypes = [this.rootItemType, ...this.rootItemTypes];
        }
      } else if (this.rootItemTypes.length > 0) {
        this.rootItemType = this.rootItemTypes[0];
      } else {
        // Fallback: pick any item type present
        const any = this.itemTypes[0];
        if (!any) {
          throw new Error('Invalid export: missing item types');
        }
        this.rootItemType = any;
        this.rootItemTypes = [any];
      }
    }

    this.rootItemTypes = this.ensureRootCoverage(this.rootItemTypes);
    if (!this.rootItemType && this.rootItemTypes.length > 0) {
      this.rootItemType = this.rootItemTypes[0];
    }
  }

  get fields() {
    return Array.from(this.fieldsById.values());
  }

  get fieldsets() {
    return Array.from(this.fieldsetsById.values());
  }

  get itemTypes() {
    return Array.from(this.itemTypesById.values());
  }

  get plugins() {
    return Array.from(this.pluginsById.values());
  }

  getItemTypeById(itemTypeId: string) {
    const itemType = this.itemTypesById.get(String(itemTypeId));

    if (!itemType) {
      throw new Error('Not existing');
    }

    return itemType;
  }

  getPluginById(pluginId: string) {
    const plugin = this.pluginsById.get(String(pluginId));

    if (!plugin) {
      throw new Error('Not existing');
    }

    return plugin;
  }

  getItemTypeFields(itemType: SchemaTypes.ItemType) {
    return (
      get(itemType, 'relationships.fields.data', []) as Array<{ id: string }>
    )
      .map((f) => String(f.id))
      .map((fid) => this.fieldsById.get(String(fid)))
      .filter(isDefined);
  }

  getItemTypeFieldsets(itemType: SchemaTypes.ItemType) {
    return (
      get(itemType, 'relationships.fieldsets.data', []) as Array<{
        id: string;
      }>
    )
      .map((fs) => String(fs.id))
      .map((fsid) => this.fieldsetsById.get(String(fsid)))
      .filter(isDefined);
  }

  private ensureRootCoverage(
    initialRoots: SchemaTypes.ItemType[],
  ): SchemaTypes.ItemType[] {
    if (this.itemTypes.length === 0) {
      return [];
    }

    const adjacency = new Map<string, Set<string>>();

    const ensureNeighbors = (id: string) => {
      const key = String(id);
      if (!adjacency.has(key)) {
        adjacency.set(key, new Set());
      }
      return adjacency.get(key)!;
    };

    for (const itemType of this.itemTypes) {
      const currentId = String(itemType.id);
      const neighbors = ensureNeighbors(currentId);
      const fields = this.getItemTypeFields(itemType);

      for (const field of fields) {
        for (const rawLinkedId of findLinkedItemTypeIds(field)) {
          const linkedId = String(rawLinkedId);
          if (!this.itemTypesById.has(linkedId) || linkedId === currentId) {
            continue;
          }
          neighbors.add(linkedId);
          ensureNeighbors(linkedId).add(currentId);
        }
      }
    }

    const visited = new Set<string>();
    const result: SchemaTypes.ItemType[] = [];
    const resultIds = new Set<string>();

    const visitFrom = (startId: string) => {
      const queue: string[] = [startId];
      while (queue.length > 0) {
        const current = String(queue.shift()!);
        if (visited.has(current)) {
          continue;
        }
        visited.add(current);
        const neighbors = adjacency.get(current);
        if (!neighbors) {
          continue;
        }
        for (const neighbor of neighbors) {
          if (!visited.has(neighbor)) {
            queue.push(neighbor);
          }
        }
      }
    };

    const addSeed = (itemType: SchemaTypes.ItemType | undefined) => {
      if (!itemType) return;
      const id = String(itemType.id);
      if (!resultIds.has(id)) {
        resultIds.add(id);
        result.push(itemType);
      }
      visitFrom(id);
    };

    for (const root of initialRoots) {
      addSeed(root);
    }

    if (result.length === 0) {
      const fallbackRoot =
        this.rootItemType ??
        this.itemTypesById.values().next().value ??
        undefined;
      addSeed(fallbackRoot);
    }

    for (const itemType of this.itemTypes) {
      const id = String(itemType.id);
      if (!visited.has(id)) {
        addSeed(itemType);
      }
    }

    return result;
  }
}
