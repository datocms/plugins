import type { SchemaTypes } from '@datocms/cma-client';
import { get } from 'lodash-es';
import { findLinkedItemTypeIds } from '@/utils/datocms/schema';
import { isDefined } from '@/utils/isDefined';
import type { ExportDoc } from '@/utils/types';

/**
 * Normalizes an export document into easy-to-query maps, helping both import and graph builders.
 */
export class ExportSchema {
  public rootItemType: SchemaTypes.ItemType;
  public rootItemTypes: SchemaTypes.ItemType[];
  public itemTypesById: Map<string, SchemaTypes.ItemType>;
  public pluginsById: Map<string, SchemaTypes.Plugin>;
  public fieldsById: Map<string, SchemaTypes.Field>;
  public fieldsetsById: Map<string, SchemaTypes.Fieldset>;

  constructor(exportDoc: ExportDoc) {
    this.itemTypesById = new Map();
    for (const itemType of exportDoc.entities.filter(
      (e): e is SchemaTypes.ItemType => e.type === 'item_type',
    )) {
      // Normalize ID to string to avoid number/string key mismatches
      this.itemTypesById.set(String(itemType.id), itemType);
    }

    this.pluginsById = new Map();
    for (const plugin of exportDoc.entities.filter(
      (e): e is SchemaTypes.Plugin => e.type === 'plugin',
    )) {
      this.pluginsById.set(String(plugin.id), plugin);
    }

    this.fieldsById = new Map();
    for (const field of exportDoc.entities.filter(
      (e): e is SchemaTypes.Field => e.type === 'field',
    )) {
      this.fieldsById.set(String(field.id), field);
    }

    this.fieldsetsById = new Map();
    for (const fieldset of exportDoc.entities.filter(
      (e): e is SchemaTypes.Fieldset => e.type === 'fieldset',
    )) {
      this.fieldsetsById.set(String(fieldset.id), fieldset);
    }

    // Compute roots by inspecting field link targets (no incoming edges)
    const targetItemTypeIds = new Set<string>();
    for (const field of this.fields) {
      const itemTypeId = String(field.relationships.item_type.data.id);
      for (const linkedItemTypeId of findLinkedItemTypeIds(field)) {
        if (String(linkedItemTypeId) !== itemTypeId) {
          targetItemTypeIds.add(String(linkedItemTypeId));
        }
      }
    }

    this.rootItemTypes = this.itemTypes.filter(
      (itemType) => !targetItemTypeIds.has(itemType.id),
    );

    if (exportDoc.version === '1') {
      if (this.rootItemTypes.length !== 1) {
        throw new Error(
          'This export file was generated by an older version of this plugin, and it is invalid because the initial model/block model cannot be determined. Please update to the most recent version of the plugin and export your schema once more.',
        );
      }
      this.rootItemType = this.rootItemTypes[0];
    } else {
      // Prefer explicit root in v2 for backward compatibility; fall back to computed roots
      const explicitRootId = exportDoc.rootItemTypeId;
      if (explicitRootId) {
        this.rootItemType = this.getItemTypeById(String(explicitRootId));
        // Ensure it exists in the list, even if incoming edge analysis differs
        if (
          !this.rootItemTypes.find(
            (it) => String(it.id) === String(explicitRootId),
          )
        ) {
          this.rootItemTypes = [this.rootItemType, ...this.rootItemTypes];
        }
      } else if (this.rootItemTypes.length > 0) {
        this.rootItemType = this.rootItemTypes[0];
      } else {
        // Fallback: pick any item type present
        const any = this.itemTypes[0];
        if (!any) {
          throw new Error('Invalid export: missing item types');
        }
        this.rootItemType = any;
        this.rootItemTypes = [any];
      }
    }
  }

  get fields() {
    return Array.from(this.fieldsById.values());
  }

  get fieldsets() {
    return Array.from(this.fieldsetsById.values());
  }

  get itemTypes() {
    return Array.from(this.itemTypesById.values());
  }

  get plugins() {
    return Array.from(this.pluginsById.values());
  }

  getItemTypeById(itemTypeId: string) {
    const itemType = this.itemTypesById.get(String(itemTypeId));

    if (!itemType) {
      throw new Error('Not existing');
    }

    return itemType;
  }

  getPluginById(pluginId: string) {
    const plugin = this.pluginsById.get(String(pluginId));

    if (!plugin) {
      throw new Error('Not existing');
    }

    return plugin;
  }

  getItemTypeFields(itemType: SchemaTypes.ItemType) {
    return (
      get(itemType, 'relationships.fields.data', []) as Array<{ id: string }>
    )
      .map((f) => String(f.id))
      .map((fid) => this.fieldsById.get(String(fid)))
      .filter(isDefined);
  }

  getItemTypeFieldsets(itemType: SchemaTypes.ItemType) {
    return (
      get(itemType, 'relationships.fieldsets.data', []) as Array<{
        id: string;
      }>
    )
      .map((fs) => String(fs.id))
      .map((fsid) => this.fieldsetsById.get(String(fsid)))
      .filter(isDefined);
  }
}
